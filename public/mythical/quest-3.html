<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Protocol of Binding - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }

        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-mythical">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/Azure-Samples/azure-ai-travel-agents" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">The Enchanted Kingdom of Azure AI Agents</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Protocol of Binding</h1>
<hr>
<p>In the mystical Kingdom of Azure, the Grand Mage LlamaIndex has summoned you to unravel the secrets of the Protocol of Binding. This ancient spell, known as the Model Context Protocol (MCP), empowers enchanted tools to work harmoniously across realms of TypeScript, Python, Java, and .NET. Your mission is to explore how these tools are bound together, enabling seamless communication and dynamic discovery. Venture forth, brave hero, and uncover the magical incantations that orchestrate this enchanted system.</p>
<h2>Key Takeaways</h2>
<p>After completing this quest, you will understand:</p>
<ul>
<li>üéØ <strong>Dynamic Tool Discovery</strong>: How MCP enables real-time identification and configuration of magical tools across multiple servers.</li>
<li>üîç <strong>Transport Mechanisms</strong>: The differences between HTTP and SSE transports in MCP client implementations and their trade-offs.</li>
<li>‚ö° <strong>Error Handling Patterns</strong>: How robust error handling ensures stability when tools fail or servers are unreachable.</li>
<li>üí° <strong>Polyglot Integration</strong>: How MCP bridges communication between services written in different programming languages.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">src/api/src/mcp/mcp-http-client.ts</code></a></h3>
<p>The <code class="inline-code">mcp-http-client.ts</code> file contains the enchanted HTTP client that binds tools to the Grand Mage&#39;s orchestration system using the Streamable HTTP transport. This client allows the Triage Mage to summon tools dynamically, invoke their spells, and gracefully disconnect when their services are no longer needed. The file demonstrates how MCP notifications are handled and how tools can be invoked with structured arguments.</p>
<h4>Highlights</h4>
<ul>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts#L42" target="_blank" rel="noopener noreferrer"><code class="inline-code">MCPClient.connect()</code></a> establishes a magical link to the server, ensuring tools can be summoned.</li>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts#L47" target="_blank" rel="noopener noreferrer"><code class="inline-code">MCPClient.listTools()</code></a> retrieves a list of available tools, enabling dynamic discovery.</li>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts#L52" target="_blank" rel="noopener noreferrer"><code class="inline-code">MCPClient.callTool()</code></a> invokes a specific tool with magical arguments, performing its spell.</li>
<li>Notification handling for <code class="inline-code">ToolListChangedNotificationSchema</code> ensures the system reacts to tool updates in real time.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">async connect() {
  await this.client.connect(this.transport);
  console.log(&#39;Connected to server&#39;);
}
</code></pre>
<ul>
<li>Establishes a connection to the MCP server using Streamable HTTP transport.</li>
<li>Ensures tools are accessible for invocation once the connection is established.</li>
<li>Demonstrates asynchronous initialization for reliability.</li>
</ul>
<hr>
<pre><code class="language-typescript">async listTools() {
  const result = await this.client.listTools();
  return result.tools;
}
</code></pre>
<ul>
<li>Retrieves a list of tools available on the MCP server.</li>
<li>Enables dynamic discovery for orchestrating workflows.</li>
<li>Illustrates the use of MCP&#39;s standardized tool listing schema.</li>
</ul>
<hr>
<pre><code class="language-typescript">async callTool(name: string, toolArgs: string) {
  console.log(`Calling tool ${name} with arguments:`, toolArgs);

  return await this.client.callTool({
    name,
    arguments: JSON.parse(toolArgs),
  });
}
</code></pre>
<ul>
<li>Executes a specific tool with structured arguments.</li>
<li>Demonstrates JSON parsing for argument validation.</li>
<li>Provides a foundation for invoking specialized agents dynamically.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-sse-client.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">src/api/src/mcp/mcp-sse-client.ts</code></a></h3>
<p>The <code class="inline-code">mcp-sse-client.ts</code> file contains the legacy Server-Sent Events (SSE) client used for connecting to MCP servers. Though considered ancient magic, it serves as an example of how tools were bound in earlier versions of the protocol. This file highlights the differences between SSE and HTTP transports in handling tool discovery and invocation.</p>
<h4>Highlights</h4>
<ul>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts#L42" target="_blank" rel="noopener noreferrer"><code class="inline-code">MCPClient.connect()</code></a> establishes a connection to the MCP server using SSE transport.</li>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts#L47" target="_blank" rel="noopener noreferrer"><code class="inline-code">MCPClient.listTools()</code></a> fetches available tools, similar to the HTTP client but with SSE-specific handling.</li>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts#L52" target="_blank" rel="noopener noreferrer"><code class="inline-code">MCPClient.callTool()</code></a> invokes tools using the SSE transport, showcasing compatibility with older protocols.</li>
<li>Error handling ensures graceful failure when the connection is disrupted.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">connect() {
  return tracer.startActiveSpan(&quot;connect&quot;, async (span) =&gt; {
    log(&quot;Connecting to MCP SSE server&quot;);
    try {
      await this.client.connect(this.transport);
      log(&quot;Connected to MCP SSE server&quot;);
      span.end();
      return this.client;
    } catch (error: any) {
      log(&quot;Error connecting to MCP SSE server:&quot;, error);
      span.setStatus({ code: 2, message: (error as Error).message });
      span.end();
      throw new Error(
        `Failed to connect to MCP SSE server: ${(error as Error).message}`
      );
    }
  });
}
</code></pre>
<ul>
<li>Establishes a connection using SSE transport, highlighting the legacy implementation.</li>
<li>Uses OpenTelemetry tracing for observability and debugging.</li>
<li>Demonstrates robust error handling for connection failures.</li>
</ul>
<hr>
<pre><code class="language-typescript">async listTools() {
  return tracer.startActiveSpan(&quot;listTools&quot;, async (span) =&gt; {
    log(&quot;Tools&quot;, this.tools);
    const toolsResult = await this.client.listTools();
    this.tools = toolsResult.tools;
    log(&quot;Tools: &quot;, toolsResult);
    span.end();
    return toolsResult;
  });
}
</code></pre>
<ul>
<li>Fetches available tools on the MCP server using SSE transport.</li>
<li>Enables dynamic discovery for orchestrating workflows.</li>
<li>Integrates tracing for monitoring tool listing operations.</li>
</ul>
<hr>
<pre><code class="language-typescript">async callTool(toolName: string, args: Record&lt;string, any&gt;) {
  console.log(`Called ${toolName} with params:`, args);
  return tracer.startActiveSpan(&quot;processQuery&quot;, async (span) =&gt; {
    log(&quot;Tools&quot;, this.tools);

    const toolResult = await this.client.callTool({
      name: toolName,
      arguments: args,
    });

    log(&quot;Tool result&quot;, toolResult);
    span.end();
    return toolResult;
  });
}
</code></pre>
<ul>
<li>Invokes a specific tool using SSE transport.</li>
<li>Demonstrates structured argument handling and tool invocation.</li>
<li>Highlights tracing integration for monitoring tool execution.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-tools.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">src/api/src/mcp/mcp-tools.ts</code></a></h3>
<p>The <code class="inline-code">mcp-tools.ts</code> file acts as the binding spell, connecting the Grand Mage&#39;s orchestration system to tools across multiple MCP servers. It dynamically initializes clients based on their transport type (HTTP or SSE) and retrieves tool lists. This file is the cornerstone of dynamic tool discovery and server reachability checks.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">client(config)</code> initializes MCP clients based on transport type, enabling seamless integration.</li>
<li><code class="inline-code">mcpToolsList(config)</code> retrieves tools from all configured servers, ensuring dynamic discovery.</li>
<li><code class="inline-code">McpServerDefinition</code> type defines the structure of server configurations, providing clarity and consistency.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">function client(config: LlamaIndexMCPClientOptions): MCPSSEClient | MCPHTTPClient {
  console.log(`Initializing MCP client`);
  console.log(`Using configuration:`, {config});

  if (config.type === &quot;sse&quot;) {
    // legacy implementation using SSE
    return new MCPSSEClient(&quot;llamaindex-sse-client&quot;, config.url, config.accessToken);
  } else {
    return new MCPHTTPClient(&quot;llamaindex-http-client&quot;, config.url, config.accessToken);
  }
}
</code></pre>
<ul>
<li>Dynamically initializes MCP clients based on transport type (HTTP or SSE).</li>
<li>Demonstrates flexibility in supporting legacy and modern protocols.</li>
<li>Provides a foundation for connecting to multiple MCP servers.</li>
</ul>
<hr>
<pre><code class="language-typescript">export async function mcpToolsList(config: McpServerDefinition[]) {
  return await Promise.all(
    config.map(async ({ id, name, config }) =&gt; {
      const { url, type } = config;
      const mcpClient = client(config);
      
      try {
        console.log(`Connecting to MCP server ${name} at ${url}`);
        await mcpClient.connect();
        console.log(`MCP server ${name} is reachable`);
        const tools = await mcpClient.listTools();

        console.log(`MCP server ${name} has ${tools.length} tools`);
        return {
          id,
          name,
          url,
          type,
          reachable: true,
          selected: id !== &quot;echo-ping&quot;,
          tools,
        };
      } catch (error: unknown) {
        console.error(
          `MCP server ${name} is not reachable`,
          (error as Error).message
        );
        return {
          id,
          name,
          url,
          type,
          reachable: false,
          selected: false,
          tools: [],
          error: (error as Error).message,
        };
      }
    })
  );
}
</code></pre>
<ul>
<li>Retrieves tools from all configured MCP servers.</li>
<li>Implements reachability checks to ensure servers are operational.</li>
<li>Demonstrates error handling for unreachable servers.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Compare the HTTP and SSE transports to understand their trade-offs in performance and compatibility.</li>
<li>Study the error handling patterns in <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-tools.ts#L31" target="_blank" rel="noopener noreferrer"><code class="inline-code">mcpToolsList()</code></a> to learn how the system gracefully handles server failures.</li>
<li>Explore how <code class="inline-code">McpServerDefinition</code> provides a consistent structure for managing server configurations.</li>
</ul>
<h2>Try This</h2>
<p>Challenge yourself to deepen your understanding:</p>
<ol>
<li><p><strong>Add a New MCP Server</strong>: Create a new MCP server using Python or Java and integrate it into the <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-tools.ts#L31" target="_blank" rel="noopener noreferrer"><code class="inline-code">mcpToolsList()</code></a> function. Test its reachability and tool discovery.</p>
<ul>
<li>Example: &quot;Create a Python FastAPI server that provides a new tool for currency conversion. Add its configuration to <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-tools.ts#L31" target="_blank" rel="noopener noreferrer"><code class="inline-code">mcpToolsList()</code></a> and test its integration.&quot;</li>
</ul>
</li>
<li><p><strong>Trace Tool Invocation Flow</strong>: Add console logs to <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-sse-client.ts#L68" target="_blank" rel="noopener noreferrer"><code class="inline-code">callTool()</code></a> in both <code class="inline-code">mcp-http-client.ts</code> and <code class="inline-code">mcp-sse-client.ts</code> to observe the complete flow of tool invocation. Analyze how arguments are handled and results are returned.</p>
<ul>
<li>Example: &quot;Use the logs to compare HTTP and SSE transport behavior during tool execution.&quot;</li>
</ul>
</li>
<li><p><strong>Enhance Error Feedback</strong>: Modify the error handling in <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-tools.ts#L31" target="_blank" rel="noopener noreferrer"><code class="inline-code">mcpToolsList()</code></a> to provide more descriptive messages, including suggestions for resolving server connectivity issues. This will improve debugging and developer experience.</p>
</li>
</ol>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries of the enchanted kingdom&#39;s magical codebase.</p>
<p>From the astral forges of wisdom, you have bound the second arcane seal of &quot;The Protocol of Binding&quot;‚Äîa triumph worthy of the bards, heralding your rise as a steadfast champion in this grand odyssey! ‚ö°üíé‚≠ê</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>