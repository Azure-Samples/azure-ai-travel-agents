<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Protocol of Discovery - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }

        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-mythical">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/Azure-Samples/azure-ai-travel-agents" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">The Enchanted Kingdom of Azure Agents</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Theme</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Protocol of Discovery</h1>
<hr>
<p>In the mystical Kingdom of Azure Agents, the council of enchanted AI agents gathers to unveil the secrets of the <strong>Protocol of Discovery</strong>. This ancient spell, powered by the <strong>Crystal of Orchestration</strong>, enables the seamless coordination of tools across realms, ensuring every traveler‚Äôs quest is met with precision. As you delve into the arcane workings of MCP (Model Context Protocol), you will uncover how these magical protocols bind the kingdom‚Äôs diverse tools into a harmonious symphony of dynamic discovery and execution.</p>
<h2>Key Takeaways</h2>
<p>After completing this quest, you will understand:</p>
<ul>
<li>üéØ <strong>MCP Client Design</strong>: How the MCP client establishes connections and invokes tools dynamically.</li>
<li>üîç <strong>Tool Discovery</strong>: The process of listing available tools and validating their reachability.</li>
<li>‚ö° <strong>Transport Strategies</strong>: The differences between SSE and HTTP transport and their architectural implications.</li>
<li>üí° <strong>Dynamic Configuration</strong>: How tool configurations enable flexibility and extensibility in multi-agent systems.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">src/api/src/mcp/mcp-http-client.ts</code></a></h3>
<p>This file showcases the HTTP-based MCP client, responsible for connecting to MCP servers, discovering tools, and invoking their magical abilities. It uses <code class="inline-code">StreamableHTTPClientTransport</code> for efficient communication and event handling, making it a cornerstone of the tool discovery process.</p>
<h4>Highlights</h4>
<ul>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts#L42" target="_blank" rel="noopener noreferrer"><code class="inline-code">MCPClient.connect</code></a> establishes a connection to the MCP server using HTTP transport.</li>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts#L47" target="_blank" rel="noopener noreferrer"><code class="inline-code">MCPClient.listTools</code></a> retrieves a list of all tools available on the server.</li>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts#L52" target="_blank" rel="noopener noreferrer"><code class="inline-code">MCPClient.callTool</code></a> invokes a specific tool by name, passing arguments dynamically.</li>
<li>Event handling for tool list changes ensures real-time updates.</li>
<li>Defensive programming patterns prevent invalid tool invocations.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">async connect() {
  await this.client.connect(this.transport);
  console.log(&#39;Connected to server&#39;);
}

async listTools() {
  const result = await this.client.listTools();
  return result.tools;
}

async callTool(name: string, toolArgs: string) {
  console.log(`Calling tool ${name} with arguments:`, toolArgs);

  return await this.client.callTool({
    name,
    arguments: JSON.parse(toolArgs),
  });
}
</code></pre>
<ul>
<li>The <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-sse-client.ts#L39" target="_blank" rel="noopener noreferrer"><code class="inline-code">connect</code></a> method establishes a reliable connection to the MCP server, ensuring readiness for tool interactions.</li>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-sse-client.ts#L57" target="_blank" rel="noopener noreferrer"><code class="inline-code">listTools</code></a> dynamically retrieves tool metadata, enabling discovery and validation.</li>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-sse-client.ts#L68" target="_blank" rel="noopener noreferrer"><code class="inline-code">callTool</code></a> demonstrates robust argument parsing and tool invocation, showcasing flexibility in handling diverse tool configurations.</li>
<li>These methods illustrate core MCP client functionality, emphasizing modularity and extensibility.</li>
<li>The real-time event handling pattern highlights the importance of keeping tool states updated.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-sse-client.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">src/api/src/mcp/mcp-sse-client.ts</code></a></h3>
<p>This file introduces an alternative transport strategy using Server-Sent Events (SSE). While marked as legacy, it demonstrates the foundational principles of MCP tool discovery and invocation.</p>
<h4>Highlights</h4>
<ul>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts#L42" target="_blank" rel="noopener noreferrer"><code class="inline-code">MCPClient.connect</code></a> initializes SSE transport and connects to the server.</li>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts#L47" target="_blank" rel="noopener noreferrer"><code class="inline-code">MCPClient.listTools</code></a> fetches available tools via SSE, maintaining tool state locally.</li>
<li><a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-http-client.ts#L52" target="_blank" rel="noopener noreferrer"><code class="inline-code">MCPClient.callTool</code></a> invokes tools using SSE, enabling streaming responses.</li>
<li>Integration with OpenTelemetry for tracing and observability.</li>
<li>Legacy implementation highlights trade-offs between SSE and HTTP transport.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">connect() {
  return tracer.startActiveSpan(&quot;connect&quot;, async (span) =&gt; {
    log(&quot;Connecting to MCP SSE server&quot;);
    try {
      await this.client.connect(this.transport);
      log(&quot;Connected to MCP SSE server&quot;);
      span.end();
      return this.client;
    } catch (error: any) {
      log(&quot;Error connecting to MCP SSE server:&quot;, error);
      span.setStatus({ code: 2, message: (error as Error).message });
      span.end();
      throw new Error(
        `Failed to connect to MCP SSE server: ${(error as Error).message}`
      );
    }
  });
}
</code></pre>
<ul>
<li>The <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-sse-client.ts#L39" target="_blank" rel="noopener noreferrer"><code class="inline-code">connect</code></a> method uses OpenTelemetry to trace connection attempts, providing insights into server accessibility.</li>
<li>Error handling ensures stability by capturing and reporting connection issues.</li>
<li>The use of SSE transport demonstrates a streaming-based approach to tool invocation.</li>
<li>This implementation highlights legacy considerations and the need for modern alternatives.</li>
<li>Observability patterns improve debugging and system monitoring capabilities.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-tools.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">src/api/src/mcp/mcp-tools.ts</code></a></h3>
<p>This file orchestrates tool discovery across multiple MCP servers, leveraging dynamic configuration and transport strategies. It acts as the bridge between the orchestrator and individual MCP clients.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">client(config)</code> initializes MCP clients based on transport type (HTTP or SSE).</li>
<li><code class="inline-code">mcpToolsList(config)</code> retrieves tool lists from multiple MCP servers, validating their reachability.</li>
<li><code class="inline-code">McpServerDefinition</code> type defines server configurations for dynamic tool discovery.</li>
<li>Support for both legacy and modern transport strategies ensures backward compatibility.</li>
<li>Comprehensive error handling provides detailed feedback on unreachable servers.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">export async function mcpToolsList(config: McpServerDefinition[]) {
  return await Promise.all(
    config.map(async ({ id, name, config }) =&gt; {
      const { url, type } = config;
      const mcpClient = client(config);
      
      try {
        console.log(`Connecting to MCP server ${name} at ${url}`);
        await mcpClient.connect();
        console.log(`MCP server ${name} is reachable`);
        const tools = await mcpClient.listTools();

        console.log(`MCP server ${name} has ${tools.length} tools`);
        return {
          id,
          name,
          url,
          type,
          reachable: true,
          selected: id !== &quot;echo-ping&quot;,
          tools,
        };
      } catch (error: unknown) {
        console.error(
          `MCP server ${name} is not reachable`,
          (error as Error).message
        );
        return {
          id,
          name,
          url,
          type,
          reachable: false,
          selected: false,
          tools: [],
          error: (error as Error).message,
        };
      }
    })
  );
}
</code></pre>
<ul>
<li>The <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-tools.ts#L31" target="_blank" rel="noopener noreferrer"><code class="inline-code">mcpToolsList</code></a> method dynamically queries multiple MCP servers, ensuring tool availability across realms.</li>
<li>Error handling captures unreachable servers, providing detailed diagnostics for debugging.</li>
<li>The use of <code class="inline-code">Promise.all</code> enables parallel discovery, optimizing performance in multi-server environments.</li>
<li>Flexible configurations allow seamless integration of legacy and modern transport types.</li>
<li>This approach emphasizes scalability and extensibility in multi-agent systems.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Compare the HTTP and SSE transport strategies to understand their trade-offs in tool invocation.</li>
<li>Explore how the <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-tools.ts#L31" target="_blank" rel="noopener noreferrer"><code class="inline-code">mcpToolsList</code></a> method uses dynamic configurations to manage tool discovery across diverse servers.</li>
<li>Observe how OpenTelemetry tracing is integrated into the SSE client for enhanced observability.</li>
</ul>
<h2>Try This</h2>
<p>Challenge yourself to deepen your understanding:</p>
<ol>
<li><strong>Add a New MCP Server</strong>: Create a new MCP server configuration in <code class="inline-code">mcp-tools.ts</code> and test its integration using the <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-tools.ts#L31" target="_blank" rel="noopener noreferrer"><code class="inline-code">mcpToolsList</code></a> method. Experiment with different transport types (HTTP vs. SSE) to observe their behavior.</li>
<li><strong>Trace Tool Invocation</strong>: Add tracing logs to <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-sse-client.ts#L68" target="_blank" rel="noopener noreferrer"><code class="inline-code">callTool</code></a> methods in both HTTP and SSE clients. Run the system and observe how tool invocation flows through the transport layers.</li>
<li><strong>Enhance Error Feedback</strong>: Modify the error handling in <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/mcp/mcp-tools.ts#L31" target="_blank" rel="noopener noreferrer"><code class="inline-code">mcpToolsList</code></a> to include suggestions for resolving connection issues. Test how this improves debugging and user experience.</li>
</ol>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries of the enchanted AI kingdom.</p>
<p>By the luminous stars of the Celestial Forge, you have unveiled the second arcane seal of &#39;The Protocol of Discovery,&#39; forging onward with the valor of a true seeker‚Äîmay your next quests blaze as brightly as a phoenix&#39;s ascent! ‚ö°üíéüì°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>