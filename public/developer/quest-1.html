<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Workflow Orchestration - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }

        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-developer">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/Azure-Samples/azure-ai-travel-agents" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">Multi-Agent Orchestration with Azure AI Travel Agents</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Adventure</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 1: Multi-Agent Orchestration with LlamaIndex</h1>
<hr>
<p>In the bustling world of AI-powered travel management, the LlamaIndex orchestrator is the central hub where specialized agents collaborate to deliver seamless customer experiences. From understanding customer queries to recommending destinations and planning itineraries, this system demonstrates the power of multi-agent workflows. By leveraging the Model Context Protocol (MCP), developers can dynamically integrate and coordinate tools written in diverse languages like TypeScript, Python, Java, and .NET. Dive into the architecture and learn how these agents are configured and managed to create a scalable and efficient travel solution.</p>
<h2>Key Takeaways</h2>
<p>After completing this quest, you will understand:</p>
<ul>
<li>üéØ <strong>Agent Orchestration</strong>: How LlamaIndex coordinates multiple agents and their tools to handle complex workflows.</li>
<li>üîç <strong>Tool Configuration</strong>: How MCP tools are dynamically registered and discovered for seamless integration.</li>
<li>‚ö° <strong>Streaming Responses</strong>: How Server-Sent Events (SSE) enable real-time communication between agents and the client.</li>
<li>üí° <strong>Error Handling</strong>: How the system gracefully manages failures during tool execution or streaming.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/index.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">src/api/src/index.ts</code></a></h3>
<p>This file serves as the entry point for the Express.js API, orchestrating the interaction between the client and the multi-agent system. It defines endpoints for health checks, tool discovery, and the chat interface, which leverages Server-Sent Events (SSE) for streaming responses. The <code class="inline-code">apiRouter.post(&quot;/chat&quot;)</code> endpoint is particularly critical, as it initializes agents and handles the streaming of real-time responses.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">apiRouter.post(&quot;/chat&quot;)</code> manages the chat endpoint, streaming agent responses to the client.</li>
<li><code class="inline-code">pipeline(readableStream, res)</code> streams data from agents to the client, ensuring real-time updates.</li>
<li><code class="inline-code">apiRouter.get(&quot;/tools&quot;)</code> fetches and lists all available MCP tools for dynamic discovery.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">apiRouter.post(&quot;/chat&quot;, async (req, res) =&gt; {
  req.on(&quot;close&quot;, () =&gt; {
    console.log(&quot;Client disconnected, aborting...&quot;);
  });

  if (!req.body) {
    console.error(&quot;Request body is undefined. Check Content-Type header in the request.&quot;);
    return res.status(400).json({
      error: &quot;Request body is undefined. Make sure to set Content-Type to application/json.&quot;,
    });
  }

  const message = req.body.message;
  const tools = req.body.tools;
  console.log(&quot;Tools to use:&quot;, JSON.stringify(tools, null, 2));

  if (!message) {
    return res.status(400).json({ error: &quot;Message is required&quot; });
  }

  res.setHeader(&quot;Content-Type&quot;, &quot;text/event-stream&quot;);
  res.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
  res.setHeader(&quot;Connection&quot;, &quot;keep-alive&quot;);

  try {
    const agents = await setupAgents(tools);
    const context = agents.run(message);

    const readableStream = new Readable({
      async read() {
        try {
          for await (const event of context) {
            const { displayName, data } = event;
            const serializedData = JSON.stringify({
              type: &quot;metadata&quot;,
              agent: (data as any)?.currentAgentName || null,
              event: displayName,
              data: data ? JSON.parse(JSON.stringify(data)) : null,
            });
            this.push(serializedData + &quot;\n\n&quot;);
            console.log(&quot;Pushed event:&quot;, serializedData);
          }
          this.push(null);
        } catch (error: any) {
          console.error(&quot;Error during streaming:&quot;, error?.message);
        }
      },
    });

    await pipeline(readableStream, res);
  } catch (error) {
    console.error(&quot;Error occurred:&quot;, error);
    if (!res.headersSent) {
      res.status(500).json({ error: (error as any).message });
    } else {
      res.write(`${JSON.stringify({ type: &quot;error&quot;, message: (error as any).message })}\n\n`);
      res.end();
    }
  }
});
</code></pre>
<ul>
<li>This code initializes the chat workflow by setting up agents and streaming their responses to the client.</li>
<li>The <code class="inline-code">Readable</code> stream ensures real-time updates, pushing events as they occur.</li>
<li>Error handling ensures that the client receives meaningful feedback when issues arise.</li>
<li>The <code class="inline-code">pipeline</code> function efficiently manages the data flow between the readable stream and the HTTP response.</li>
<li>The use of Server-Sent Events (SSE) enables a live, interactive user experience.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/orchestrator/llamaindex/tools/index.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">src/api/src/orchestrator/llamaindex/tools/index.ts</code></a></h3>
<p>This file defines the configuration for all MCP tools integrated into the system. Each tool is described with its endpoint, transport type, and additional metadata, enabling the orchestrator to dynamically discover and use these tools.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">McpToolsConfig()</code> provides a centralized configuration for all MCP tools.</li>
<li><code class="inline-code">MCP_API_HTTP_PATH</code> and <code class="inline-code">MCP_API_SSE_PATH</code> constants define standard API endpoints for tools.</li>
<li>Tool configuration objects specify details like URL, transport type, and authorization headers.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">export const McpToolsConfig = (): {
  [k in McpServerName]: McpServerDefinition;
} =&gt; ({
  &quot;echo-ping&quot;: {
    config: {
      url: process.env[&quot;MCP_ECHO_PING_URL&quot;] + MCP_API_HTTP_PATH,
      type: &quot;http&quot;,
      verbose: true,
      requestInit: {
        headers: {
          &quot;Authorization&quot;: &quot;Bearer &quot; + process.env[&quot;MCP_ECHO_PING_ACCESS_TOKEN&quot;],
        },
      },
      useSSETransport: false,
    },
    id: &quot;echo-ping&quot;,
    name: &quot;Echo Test&quot;,
  },
  &quot;customer-query&quot;: {
    config: {
      url: process.env[&quot;MCP_CUSTOMER_QUERY_URL&quot;] + MCP_API_HTTP_PATH,
      type: &quot;http&quot;,
      verbose: true,
      useSSETransport: false,
    },
    id: &quot;customer-query&quot;,
    name: &quot;Customer Query&quot;,
  },
  // Additional tool configurations...
});
</code></pre>
<ul>
<li>The <code class="inline-code">McpToolsConfig</code> function centralizes the configuration of all MCP tools, making it easy to add or modify tools.</li>
<li>Constants like <code class="inline-code">MCP_API_HTTP_PATH</code> ensure consistency in API endpoint definitions.</li>
<li>The <code class="inline-code">requestInit</code> object demonstrates how to include authorization headers dynamically.</li>
<li>Each tool configuration specifies whether it uses HTTP or SSE transport, enabling flexibility in communication protocols.</li>
<li>This structure supports extensibility, allowing new tools to be added with minimal changes.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/orchestrator/llamaindex/index.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">src/api/src/orchestrator/llamaindex/index.ts</code></a></h3>
<p>This file contains the <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/orchestrator/llamaindex/index.ts#L11" target="_blank" rel="noopener noreferrer"><code class="inline-code">setupAgents</code></a> function, which initializes and configures all agents in the system. It leverages the MCP tools defined in <code class="inline-code">McpToolsConfig</code> to dynamically build agents and their workflows.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">setupAgents(filteredTools)</code> dynamically initializes agents based on the specified tools.</li>
<li><code class="inline-code">multiAgent({ agents: agentsList, rootAgent: travelAgent })</code> creates the multi-agent workflow.</li>
<li><code class="inline-code">agent()</code> configuration blocks define the behavior and capabilities of each agent.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">export async function setupAgents(filteredTools: McpServerDefinition[] = []) {
  const tools = Object.fromEntries(
    filteredTools.map((tool) =&gt; [tool.id, true])
  );
  console.log(&quot;Filtered tools:&quot;, tools);

  let agentsList = [];
  let handoffTargets = [];
  let toolsList = [];
  const verbose = false;
  const mcpToolsConfig = McpToolsConfig();

  let llm: ToolCallLLM = {} as ToolCallLLM;
  try {
    llm = await llmProvider();
  } catch (error) {
    throw new Error(error instanceof Error ? error.message : String(error));
  }

  if (tools[&quot;echo-ping&quot;]) {
    const mcpServerConfig = mcpToolsConfig[&quot;echo-ping&quot;].config;
    const tools = await mcp(mcpServerConfig).tools();
    const echoAgent = agent({
      name: &quot;EchoAgent&quot;,
      systemPrompt:
        &quot;Echo back the received input. Do not respond with anything else. Always call the tools.&quot;,
      tools,
      llm,
      verbose,
    });
    agentsList.push(echoAgent);
    handoffTargets.push(echoAgent);
    toolsList.push(...tools);
  }

  // Additional agent configurations...

  const travelAgent = agent({
    name: &quot;TravelAgent&quot;,
    systemPrompt:
      &quot;Acts as a triage agent to determine the best course of action for the user&#39;s query.&quot;,
    tools: [...toolsList],
    canHandoffTo: handoffTargets
      .map((target) =&gt; target.getAgents().map((agent) =&gt; agent.name))
      .flat(),
    llm,
    verbose,
  });
  agentsList.push(travelAgent);

  return multiAgent({
    agents: agentsList,
    rootAgent: travelAgent,
    verbose,
  });
}
</code></pre>
<ul>
<li>The <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/orchestrator/llamaindex/index.ts#L11" target="_blank" rel="noopener noreferrer"><code class="inline-code">setupAgents</code></a> function dynamically configures agents based on the tools provided, ensuring flexibility and scalability.</li>
<li>Each agent is defined with a <code class="inline-code">systemPrompt</code> that specifies its role and behavior.</li>
<li>The <code class="inline-code">multiAgent</code> function creates a cohesive workflow, with the <code class="inline-code">TravelAgent</code> acting as the central coordinator.</li>
<li>Tools are dynamically discovered and registered, reducing manual configuration effort.</li>
<li>The use of <code class="inline-code">llmProvider</code> abstracts the LLM initialization, allowing for different providers to be used interchangeably.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Review how the <code class="inline-code">Readable</code> stream in <code class="inline-code">apiRouter.post(&quot;/chat&quot;)</code> enables real-time updates for streaming responses.</li>
<li>Explore the <code class="inline-code">McpToolsConfig</code> function to understand how tool configurations are centralized and dynamically loaded.</li>
<li>Examine the <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/orchestrator/llamaindex/index.ts#L11" target="_blank" rel="noopener noreferrer"><code class="inline-code">setupAgents</code></a> function to see how agents are initialized and integrated into the multi-agent workflow.</li>
</ul>
<h2>Try This</h2>
<p>Challenge yourself to deepen your understanding:</p>
<ol>
<li><strong>Add a New Tool</strong>: Create a new MCP tool for currency conversion and register it in <code class="inline-code">McpToolsConfig</code>. Update <a href="https://github.com/Azure-Samples/azure-ai-travel-agents/blob/main/src/api/src/orchestrator/llamaindex/index.ts#L11" target="_blank" rel="noopener noreferrer"><code class="inline-code">setupAgents</code></a> to include a <code class="inline-code">CurrencyConversionAgent</code>.</li>
<li><strong>Trace Agent Workflow</strong>: Add <code class="inline-code">console.log</code> statements to trace the flow of a user query through the <code class="inline-code">TravelAgent</code> and its handoff targets. Observe how data is routed and processed.</li>
<li><strong>Enhance Error Handling</strong>: Modify the error handling in <code class="inline-code">apiRouter.post(&quot;/chat&quot;)</code> to provide more detailed feedback, such as listing available tools when an unknown tool is requested.</li>
</ol>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries of the Azure AI Travel Agents system.</p>
<p>Congratulations on successfully deploying the Agent Workflow Orchestration module‚Äîyour system architecture just leveled up with üöÄ precision and üíé scalability!</p>

</div>


      <div class="quest-navigation quest-navigation-bottom nav-next-only">
        <a href="quest-2.html" class="next-quest-btn">Next: Quest 2 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>